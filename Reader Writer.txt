#include <stdio.h>
#include <semaphore.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

sem_t mutex, write_sem;
int data = 0, reader_count = 0;

void* reader(void *arg) {
    sem_wait(&mutex);         // Lock the mutex to update the reader_count safely
    reader_count++;
    if (reader_count == 1)    // If this is the first reader, block writers
        sem_wait(&write_sem); // Block the writer
    sem_post(&mutex);         // Release the mutex
    
    printf("Data read: %d\n", data);  // Read data
    sleep(1);                         // Simulate reading
    
    sem_wait(&mutex);         // Lock mutex again to update reader_count
    reader_count--;
    if (reader_count == 0)    // If this is the last reader, release the writer
        sem_post(&write_sem); // Release the writer
    sem_post(&mutex);         // Release the mutex
}

void* writer(void *arg) {
    sem_wait(&write_sem);  // Wait for permission to write (exclusive access)

    data++;                // Write to the data
    printf("Data written: %d\n", data);
    sleep(1);              // Simulate writing

    sem_post(&write_sem);  // Release write semaphore
}

int main() {
    int i;
    pthread_t readers[2], writers[2]; // Two readers and two writers
    sem_init(&mutex, 0, 1);            // Initialize the mutex semaphore (binary semaphore)
    sem_init(&write_sem, 0, 1);        // Initialize the write semaphore (binary semaphore)


    for (i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer, NULL);
        pthread_create(&readers[i], NULL, reader, NULL);
    }

    // Wait for all threads to finish
    for (i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
        pthread_join(readers[i], NULL);
    }

    return 0;
}


shaunty17@DESKTOP-MSSPH5A:/mnt/d/Shounak/New/Assignment_4$ gcc reader_writer.c
shaunty17@DESKTOP-MSSPH5A:/mnt/d/Shounak/New/Assignment_4$ ./a.out
Data written: 1
Data read: 1
Data read: 1
Data written: 2