#include <stdio.h>
#include <stdbool.h>

struct Process {
    int pid;
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time;
    int waiting_time;
    int turn_around_time;
};

int main() {
    int n, time_quantum;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process proc[n];
    int arrival_time[n], burst_time[n];  // Separate arrays to hold original AT and BT

    // Input the processes data
    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter Arrival Time for Process %d: ", i + 1);
        scanf("%d", &arrival_time[i]); // Store original AT
        printf("Enter Burst Time for Process %d: ", i + 1);
        scanf("%d", &burst_time[i]); // Store original BT
        proc[i].arrival_time = arrival_time[i];
        proc[i].burst_time = burst_time[i];
        proc[i].remaining_time = burst_time[i];  // Set remaining time initially equal to burst time
    }

    printf("Enter Time Quantum: ");
    scanf("%d", &time_quantum);

    int current_time = 0;  // Current time in the system
    int completed = 0;     // Count of completed processes
    float total_TAT = 0;   // Total Turnaround Time
    float total_WT = 0;    // Total Waiting Time
    int queue[n];          // Queue for managing processes
    int front = 0, rear = 0;
    bool in_queue[n];      // Track if a process is already in the queue

    for (int i = 0; i < n; i++) {
        in_queue[i] = false; // Initialize as not in the queue
    }

    // Add processes that are available at time 0
    for (int i = 0; i < n; i++) {
        if (proc[i].arrival_time <= current_time && !in_queue[i]) {
            queue[rear++] = i;
            in_queue[i] = true;
        }
    }

    // Process scheduling loop
    while (completed < n) {
        // If the queue is empty, increment time to the next available process
        if (front == rear) {
            current_time++;
            for (int i = 0; i < n; i++) {
                if (proc[i].arrival_time <= current_time && !in_queue[i] && proc[i].remaining_time > 0) {
                    queue[rear++] = i;
                    in_queue[i] = true;
                }
            }
            continue;
        }

        int index = queue[front++]; // Dequeue the next process

        // Check if the process can complete within the time quantum
        int time_slice = (proc[index].remaining_time < time_quantum) ? proc[index].remaining_time : time_quantum;
        current_time += time_slice;
        proc[index].remaining_time -= time_slice;

        // Check for new processes arriving during the time slice
        for (int i = 0; i < n; i++) {
            if (proc[i].arrival_time <= current_time && !in_queue[i] && proc[i].remaining_time > 0) {
                queue[rear++] = i;
                in_queue[i] = true;
            }
        }

        // If the process is completed
        if (proc[index].remaining_time == 0) {
            proc[index].completion_time = current_time;
            proc[index].turn_around_time = proc[index].completion_time - proc[index].arrival_time;
            proc[index].waiting_time = proc[index].turn_around_time - proc[index].burst_time;
            total_TAT += proc[index].turn_around_time;
            total_WT += proc[index].waiting_time;
            completed++;
            in_queue[index] = false; // Mark process as completed
        } else {
            queue[rear++] = index; // Re-enqueue the incomplete process
        }
    }

    // Output results
    printf("\nPID \tAT \tBT \tCT \tTAT \tWT\n");
    for (int i = 0; i < n; i++) {
        printf("%d \t%d \t%d \t%d \t%d \t%d\n", 
               proc[i].pid, 
               arrival_time[i], // Print original arrival time
               burst_time[i],    // Print original burst time
               proc[i].completion_time, 
               proc[i].turn_around_time, 
               proc[i].waiting_time);
    }

    printf("\nAverage Waiting Time: %.2f", total_WT / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_TAT / n);

    return 0;
}


/*
shaunty17@DESKTOP-MSSPH5A:/mnt/d/Shounak/New/Assignment_3$ gcc Assignment_3_B.c
shaunty17@DESKTOP-MSSPH5A:/mnt/d/Shounak/New/Assignment_3$ ./a.out
Enter the number of processes: 3

Enter arrival time and burst time for Process 1: 0 5

Enter arrival time and burst time for Process 2: 1 4

Enter arrival time and burst time for Process 3: 2 3

Enter the time quantum: 2

Average Waiting Time = 6.00
Average Turnaround Time = 10.00

PID     Arrival Time    Burst Time      Completion Time Waiting Time    Turnaround Time
1       0               5               5               0               5
2       1               4               11              6               10
3       2               3               12              7               10
*/